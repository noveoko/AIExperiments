<div class="post-body"><p>This is the eighteenth installment of the Flask Mega-Tutorial series, in which I'm going to deploy Microblog to the DigitalOcean cloud platform.</p>
<p>You are reading the 2024 edition of the Flask Mega-Tutorial. The complete course is also available to order in e-book and paperback formats from <a href="https://amzn.to/3ahVnPN">Amazon</a>. Thank you for your support!</p>
<p>If you are looking for the 2018 edition of this course, you can find it <a href="/post/the-flask-mega-tutorial-part-i-hello-world-2018">here</a>.</p>
<p>For your reference, here is the complete list of articles in this series:</p>
<ul>
<li><a href="/post/the-flask-mega-tutorial-part-i-hello-world">Chapter 1:  Hello, World!</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-ii-templates">Chapter 2:  Templates</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-iii-web-forms">Chapter 3:  Web Forms</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-iv-database">Chapter 4:  Database</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-v-user-logins">Chapter 5:  User Logins</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-vi-profile-page-and-avatars">Chapter 6:  Profile Page and Avatars</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-vii-error-handling">Chapter 7:  Error Handling</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-viii-followers">Chapter 8:  Followers</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-ix-pagination">Chapter 9:  Pagination</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-x-email-support">Chapter 10:  Email Support</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-xi-facelift">Chapter 11:  Facelift</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-xii-dates-and-times">Chapter 12:  Dates and Times</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-xiii-i18n-and-l10n">Chapter 13:  I18n and L10n</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-xiv-ajax">Chapter 14:  Ajax</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-xv-a-better-application-structure">Chapter 15:  A Better Application Structure</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-xvi-full-text-search">Chapter 16:  Full-Text Search</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-xvii-deployment-on-linux">Chapter 17:  Deployment on Linux</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-xviii-deployment-on-digitalocean">Chapter 18:  Deployment on DigitalOcean</a> (this article)</li>
<li><a href="/post/the-flask-mega-tutorial-part-xix-deployment-on-docker-containers">Chapter 19:  Deployment on Docker Containers</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-xx-some-javascript-magic">Chapter 20:  Some JavaScript Magic</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-xxi-user-notifications">Chapter 21:  User Notifications</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-xxii-background-jobs">Chapter 22:  Background Jobs</a></li>
<li><a href="/post/the-flask-mega-tutorial-part-xxiii-application-programming-interfaces-apis">Chapter 23:  Application Programming Interfaces (APIs)</a></li>
</ul>
<p>In the previous article I showed you the "traditional" way to host a Python application, and I gave you an actual example of deployment to a Linux based server. If you are not used to manage a Linux system, you probably thought that the amount of effort that needs to be put into the task was big, and that surely there must be an easier way.</p>
<p>In this chapter I'm going to show you a completely different approach, in which you rely on a third-party <em>cloud</em> hosting provider to perform most of the administration tasks, freeing you to spend more time working on your application.</p>
<p>Many cloud hosting providers offer a managed platform on which applications can run. All you need to provide to have your application deployed on these platforms is the actual application, because the hardware, operating system, scripting language interpreters, database, etc. are all managed by the service. This type of service is called <a href="https://en.wikipedia.org/wiki/Platform_as_a_service">Platform as a Service</a>, or PaaS.</p>
<p>Sounds too good to be true, right?</p>
<p>I will look at deploying Microblog to <a href="https://www.digitalocean.com">DigitalOcean</a>, a popular cloud hosting service that is very friendly for Python applications. DigitalOcean offers a variety of pricing plans, so you can choose one that fits your budget.</p>
<p><em>The GitHub links for this chapter are: <a href="https://github.com/miguelgrinberg/microblog/tree/v0.18">Browse</a>, <a href="https://github.com/miguelgrinberg/microblog/archive/v0.18.zip">Zip</a>, <a href="https://github.com/miguelgrinberg/microblog/compare/v0.17...v0.18">Diff</a>.</em></p>
<h2>Hosting on DigitalOcean</h2>
<p>DigitalOcean is one of the leading cloud infrastructure providers. It offers a variety of services, including virtual private servers (VPS), object storage, and managed databases.</p>
<p>Deploying a web application to DigitalOcean involves creating a droplet, which is a virtual machine, and then configuring it to run your application. DigitalOcean provides a simple and intuitive interface for managing your droplets, and you can choose from a variety of operating systems and application stacks.</p>
<p>Ready to try DigitalOcean? Let's get started!</p>
<h2>Creating a DigitalOcean Account</h2>
<p>Before you can deploy to DigitalOcean, you need to have an account with them. So visit <a href="https://cloud.digitalocean.com/registrations/new">DigitalOcean</a> and create an account. Once you have an account and log in to DigitalOcean, you will have access to a dashboard, where all your droplets are listed.</p>
<h2>Installing the DigitalOcean CLI</h2>
<p>DigitalOcean provides a command-line tool for interacting with their service called <a href="https://docs.digitalocean.com/reference/doctl/">doctl</a>, available for Windows, Mac OS X, and Linux. The documentation includes installation instructions for all the supported platforms. Go ahead and install it on your system if you plan on deploying the application to test the service.</p>
<p>The first thing you should do once the CLI is installed is log in to your DigitalOcean account:</p>
<pre class="prettyprint"><code><span class="pln">$ doctl auth init</span></code></pre>
<p>DigitalOcean CLI will ask you to enter your API token. You can generate an API token from your DigitalOcean account settings.</p>
<h2>Setting Up Git</h2>
<p>The <code>git</code> tool is core to the deployment of applications to DigitalOcean, so you must install it on your system if you don't have it yet. If you don't have a package available for your operating system, you can visit the <a href="https://git-scm.com/">git website</a> to download an installer.</p>
<p>There are a lot of reasons why using <code>git</code> for your projects makes sense. If you plan to deploy to DigitalOcean, you have one more, because to deploy to DigitalOcean, your application must be in a <code>git</code> repository. If you are going to do a test deployment for Microblog, you can clone my version of this application from GitHub:</p>
<pre class="prettyprint"><code><span class="pln">$ git clone https</span><span class="pun">:</span><span class="com">//github.com/miguelgrinberg/microblog</span><span class="pln">
$ cd microblog
$ git checkout v0</span><span class="pun">.</span><span class="lit">18</span></code></pre>
<p>The <code>git checkout</code> command selects the specific commit that has the application at the point in its history that corresponds to this chapter.</p>
<p>If you prefer to work with your own code instead of mine, you can transform your own project into a <code>git</code> repository by running <code>git init .</code> on the top-level directory (note the period after <code>init</code>, which tells git that you want to create the repository in the current directory). Once the git repository is created, use the <code>git add</code> command to add all your source files, and <code>git commit</code> to commit them to the repository.</p>
<h2>Creating a DigitalOcean Droplet</h2>
<p>To create a new droplet on DigitalOcean, you can use the <code>compute droplet create</code> command from the root directory of the application:</p>
<pre class="prettyprint"><code><span class="pln">$ doctl compute droplet create flask-microblog </span><span class="pun">--</span><span class="pln">image ubuntu</span><span class="pun">-</span><span class="lit">20.04</span><span class="pun">-</span><span class="pln">x64 </span><span class="pun">--</span><span class="pln">size s</span><span class="pun">-</span><span class="lit">1vcpu</span><span class="pun">-</span><span class="lit">1gb</span><span class="pun">--</span><span class="pln">region nyc1 </span><span class="pun">--</span><span class="pln">ssh</span><span class="pun">-</span><span class="pln">keys </span><span class="pun">~/</span><span class="pln">.ssh</span><span class="pun">/</span><span class="pln">id_rsa</span><span class="pun">.</span><span class="pln">pub</span></code></pre>
<p>This command creates a droplet named <code>flask-microblog</code> using the Ubuntu 20.04 image, with 1 vCPU and 1 GB of RAM, in the New York City region. You will need to replace <code>~/.ssh/id_rsa.pub</code> with the path to your own SSH public key.</p>
<p>The output of this command will include the IP address of the newly created droplet.</p>
<h2>The Ephemeral File System</h2>
<p>The DigitalOcean platform is different from other deployment platforms in that it features an <em>ephemeral</em> file system that runs on a virtualized platform. What does that mean? It means that at any time, DigitalOcean can reset the virtual server on which your server runs back to a clean state. You cannot assume that any data that you save to the file system will persist, and in fact, DigitalOcean recycles servers very often.</p>
<p>Working under these conditions introduces some problems for my application, which uses a few files:</p>
<ul>
<li>The default SQLite database engine writes data in a disk file</li>
<li>Logs for the application are also written to the file system</li>
<li>The compiled language translation repositories are also written to local files</li>
</ul>
<p>The following sections will address these three areas.</p>
<h2>Working with a DigitalOcean Managed Database</h2>
<p>To address the first problem, I'm going to switch to a different database engine. DigitalOcean offers managed databases, including PostgreSQL. I'm going to switch to that to avoid the file-based SQLite.</p>
<p>Databases for DigitalOcean applications are provisioned with the DigitalOcean control panel or API. In this case, I'm going to create a database on the free tier:</p>
<pre class="prettyprint"><code><span class="pln">$ doctl databases create flask-microblog-db </span><span class="pun">--</span><span class="pln">engine pg </span><span class="pun">--</span><span class="pln">size db</span><span class="pun">-</span><span class="pln">s</span><span class="pun">-</span><span class="lit">1vcpu</span><span class="pun">-</span><span class="lit">1gb</span><span class="pun">--</span><span class="pln">region nyc1</span></code></pre>
<p>The URL for the newly created database is stored in a <code>DATABASE_URL</code> environment variable that will be available when the application runs on DigitalOcean's platform. This is very convenient, because the application already looks for the database URL in that variable.</p>
<p>To make sure that the <code>DATABASE_URL</code> variable is configured in your DigitalOcean droplet, you can use the following command:</p>
<pre class="prettyprint"><code><span class="pln">$ doctl compute droplet list </span><span class="pun">--</span><span class="pln">format ID,Name,Networks.V4.IPv4.IPAddress</span></code></pre>
<p>An unfortunate problem with recent versions of SQLAlchemy is that they expect Postgres database URLs to begin with <code>postgresql://</code>, instead of the <code>postgres://</code> that DigitalOcean uses. To ensure that the application can connect to the database, it is necessary to update the URL to the format required by SQLAlchemy. This can be done with a string replacement operation in the <code>Config</code> class:</p>
<p class="code_title"><em>config.py</em>: Fix Postgres database URLs to be compatible with SQLAlchemy.</p>

<pre class="prettyprint"><code class="language-python"><span class="kwd">class</span><span class="pln"> </span><span class="typ">Config</span><span class="pun">:</span><span class="pln">
    </span><span class="com"># ...</span><span class="pln">
    SQLALCHEMY_DATABASE_URI </span><span class="pun">=</span><span class="pln"> os</span><span class="pun">.</span><span class="pln">environ</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'DATABASE_URL'</span><span class="pun">,</span><span class="pln"> </span><span class="str">''</span><span class="pun">).</span><span class="pln">replace</span><span class="pun">(</span><span class="pln">
        </span><span class="str">'postgres://'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'postgresql://'</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">or</span><span class="pln"> \
        </span><span class="str">'sqlite:///'</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> os</span><span class="pun">.</span><span class="pln">path</span><span class="pun">.</span><span class="pln">join</span><span class="pun">(</span><span class="pln">basedir</span><span class="pun">,</span><span class="pln"> </span><span class="str">'app.db'</span><span class="pun">)</span><span class="pln">
    </span><span class="com"># ...</span></code></pre>
<p>This string replacement operation is safe to use even when the <code>DATABASE_URL</code> variable is set to a different database, in which case it will not affect it.</p>
<h2>Logging to stdout</h2>
<p>DigitalOcean expects applications to log directly to <code>stdout</code>. Anything the application prints to the standard output is saved and returned when you use the <code>doctl logs</code> command. So I'm going to add a configuration variable that indicates if I need to log to <code>stdout</code> or to a file like I've been doing. Here is the change in the configuration:</p>
<p class="code_title"><em>config.py</em>: Option to log to stdout.</p>

<pre class="prettyprint"><code class="language-python"><span class="kwd">class</span><span class="pln"> </span><span class="typ">Config</span><span class="pun">:</span><span class="pln">
    </span><span class="com"># ...</span><span class="pln">
    LOG_TO_STDOUT </span><span class="pun">=</span><span class="pln"> os</span><span class="pun">.</span><span class="pln">environ</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'LOG_TO_STDOUT'</span><span class="pun">)</span></code></pre>
<p>Then in the application factory function I can check this configuration to know how to configure the application's logger:</p>
<p class="code_title"><em>app/__init__.py</em>: Log to stdout or file.</p>

<pre class="prettyprint"><code class="language-python"><span class="kwd">def</span><span class="pln"> create_app</span><span class="pun">(</span><span class="pln">config_class</span><span class="pun">=</span><span class="typ">Config</span><span class="pun">):</span><span class="pln">
    </span><span class="com"># ...</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="kwd">not</span><span class="pln"> app</span><span class="pun">.</span><span class="pln">debug </span><span class="kwd">and</span><span class="pln"> </span><span class="kwd">not</span><span class="pln"> app</span><span class="pun">.</span><span class="pln">testing</span><span class="pun">:</span><span class="pln">
        </span><span class="com"># ...</span><span class="pln">

        </span><span class="kwd">if</span><span class="pln"> app</span><span class="pun">.</span><span class="pln">config</span><span class="pun">[</span><span class="str">'LOG_TO_STDOUT'</span><span class="pun">]:</span><span class="pln">
            stream_handler </span><span class="pun">=</span><span class="pln"> logging</span><span class="pun">.</span><span class="typ">StreamHandler</span><span class="pun">()</span><span class="pln">
            stream_handler</span><span class="pun">.</span><span class="pln">setLevel</span><span class="pun">(</span><span class="pln">logging</span><span class="pun">.</span><span class="pln">INFO</span><span class="pun">)</span><span class="pln">
            app</span><span class="pun">.</span><span class="pln">logger</span><span class="pun">.</span><span class="pln">addHandler</span><span class="pun">(</span><span class="pln">stream_handler</span><span class="pun">)</span><span class="pln">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="pln">
            </span><span class="kwd">if</span><span class="pln"> </span><span class="kwd">not</span><span class="pln"> os</span><span class="pun">.</span><span class="pln">path</span><span class="pun">.</span><span class="pln">exists</span><span class="pun">(</span><span class="str">'logs'</span><span class="pun">):</span><span class="pln">
                os</span><span class="pun">.</span><span class="pln">mkdir</span><span class="pun">(</span><span class="str">'logs'</span><span class="pun">)</span><span class="pln">
            file_handler </span><span class="pun">=</span><span class="pln"> </span><span class="typ">RotatingFileHandler</span><span class="pun">(</span><span class="str">'logs/microblog.log'</span><span class="pun">,</span><span class="pln">
                                               maxBytes</span><span class="pun">=</span><span class="lit">10240</span><span class="pun">,</span><span class="pln"> backupCount</span><span class="pun">=</span><span class="lit">10</span><span class="pun">)</span><span class="pln">
            file_handler</span><span class="pun">.</span><span class="pln">setFormatter</span><span class="pun">(</span><span class="pln">logging</span><span class="pun">.</span><span class="typ">Formatter</span><span class="pun">(</span><span class="pln">
                </span><span class="str">'%(asctime)s %(levelname)s: %(message)s '</span><span class="pln">
                </span><span class="str">'[in %(pathname)s:%(lineno)d]'</span><span class="pun">))</span><span class="pln">
            file_handler</span><span class="pun">.</span><span class="pln">setLevel</span><span class="pun">(</span><span class="pln">logging</span><span class="pun">.</span><span class="pln">INFO</span><span class="pun">)</span><span class="pln">
            app</span><span class="pun">.</span><span class="pln">logger</span><span class="pun">.</span><span class="pln">addHandler</span><span class="pun">(</span><span class="pln">file_handler</span><span class="pun">)</span><span class="pln">

        app</span><span class="pun">.</span><span class="pln">logger</span><span class="pun">.</span><span class="pln">setLevel</span><span class="pun">(</span><span class="pln">logging</span><span class="pun">.</span><span class="pln">INFO</span><span class="pun">)</span><span class="pln">
        app</span><span class="pun">.</span><span class="pln">logger</span><span class="pun">.</span><span class="pln">info</span><span class="pun">(</span><span class="str">'Microblog startup'</span><span class="pun">)</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> app</span></code></pre>
<p>So now I need to set the <code>LOG_TO_STDOUT</code> environment variable when the application runs in DigitalOcean, but not in other configurations. The DigitalOcean CLI makes this easy, as it provides an option to set environment variables to be used at runtime:</p>
<pre class="prettyprint"><code><span class="pln">$ doctl compute droplet update flask-microblog </span><span class="pun">--</span><span class="pln">env LOG_TO_STDOUT</span><span class="pun">=</span><span class="lit">1</span></code></pre>
<h2>Compiled Translations</h2>
<p>The third aspect of Microblog that relies on local files is the compiled language translation files. The more direct option to ensure those files never disappear from the ephemeral file system is to add the compiled language files to the git repository, so that they become part of the initial state of the application once it is deployed to DigitalOcean.</p>
<p>A more elegant option, in my opinion, is to include the <code>flask translate compile</code> command in the start-up command given to DigitalOcean, so that any time the server is restarted those files are compiled again. I'm going to go with this option, since I know that my start-up procedure is going to require more than one command anyway, as I also need to run the database migrations. So for now, I will set this problem aside, and will revisit it later when I write the start-up script.</p>
<h2>Elasticsearch Hosting</h2>
<p>Elasticsearch is one of the many services that can be added to a DigitalOcean project, but unlike PostgreSQL, this is not a service provided by DigitalOcean, but by third parties that partner with DigitalOcean to provide add-ons. At the time I'm writing this, there are several different providers of an integrated Elasticsearch service. If you prefer not to deploy the search feature, then skip this section. You will still be able to deploy the application, but the search functionality is not going to be enabled.</p>
<p>Out of the Elasticsearch options that are available as add-ons, I decided to try <a href="https://www.digitalocean.com/products/managed-databases-elasticsearch/">DigitalOcean Managed Elasticsearch</a>, which comes with a free starter plan. To add DigitalOcean Managed Elasticsearch to your account, you have to run the following command while being logged in to DigitalOcean:</p>
<pre class="prettyprint"><code><span class="pln">$ doctl databases create flask-microblog-es </span><span class="pun">--</span><span class="pln">engine es </span><span class="pun">--</span><span class="pln">size db</span><span class="pun">-</span><span class="pln">s</span><span class="pun">-</span><span class="lit">1vcpu</span><span class="pun">-</span><span class="lit">1gb</span><span class="pun">--</span><span class="pln">region nyc1</span></code></pre>
<p>This command will deploy an Elasticsearch service and leave the connection URL for the service in a <code>ELASTICSEARCH_URL</code> environment variable associated with your application. Once more keep in mind that this command will fail unless you add your credit card to your DigitalOcean account.</p>
<p>If you recall from <a href="/post/the-flask-mega-tutorial-part-xvi-full-text-search">Chapter 16</a>, my application looks for the Elasticsearch connection URL in the <code>ELASTICSEARCH_URL</code> variable, so I need to add this variable and set it to the connection URL assigned by DigitalOcean Managed Elasticsearch:</p>
<pre class="prettyprint"><code><span class="pln">$ doctl compute droplet update flask-microblog </span><span class="pun">--</span><span class="pln">env ELASTICSEARCH_URL</span><span class="pun">=</span><span class="lit">your-elasticsearch-url</span></code></pre>
<p>Here I first asked DigitalOcean to print the value of <code>ELASTICSEARCH_URL</code>, and then I added a new environment variable with the name <code>ELASTICSEARCH_URL</code> set to that same value.</p>
<p>Many other features of the application are also configured through environment variables, for example <code>SECRET_KEY</code>, <code>MS_TRANSLATOR_KEY</code>, <code>MAIL_SERVER</code> and a few more. These variables need to also be copied over to the DigitalOcean deployment, so that they are accessible to the application. The <code>doctl compute droplet update</code> can be used to transfer these variables from your <em>.env</em> file to DigitalOcean.</p>
<p>The example below configures a secret key:</p>
<pre class="prettyprint"><code><span class="pln">doctl compute droplet update flask-microblog </span><span class="pun">--</span><span class="pln">env SECRET_KEY</span><span class="pun">=</span><span class="lit">7853fbd853a249c586f7d810a7938b43</span></code></pre>
<h2>Updates to Requirements</h2>
<p>DigitalOcean expects the dependencies to be in the <em>requirements.txt</em> file, exactly like I defined it in <a href="/post/the-flask-mega-tutorial-part-xv-a-better-application-structure">Chapter 15</a>. But for the application to run on DigitalOcean I need to add two new dependencies to this file.</p>
<p>DigitalOcean does not provide a web server of its own. Instead, it expects the application to start its own web server on the port number given in the environment variable <code>$PORT</code>. Since the Flask development web server is not robust enough to use for production, I'm going to use <a href="http://gunicorn.org/">Gunicorn</a> again, the server recommended by DigitalOcean for Python applications.</p>
<p>The application will also be connecting to a PostgreSQL database, and for that SQLAlchemy requires the <code>psycopg2</code> or <code>psycopg2-binary</code> packages to be installed. The binary version is, in general, preferred as it installs an already built version of this package, as opposite to <code>psycopg2</code> which requires a C compiler to be installed to build the package during installation.</p>
<p>Both <code>gunicorn</code> and <code>psycopg2-binary</code> need to be added to the <em>requirements.txt</em> file.</p>
<h2>The Start-Up Script</h2>
<p>DigitalOcean needs to know how to execute the application, and for that it uses a start-up script. The format of this script is simple, each line includes a command that starts the process. The most common type of application that runs on DigitalOcean is a web application, and for this type of application the process name should be <code>web</code>. Below you can see a start-up script for Microblog:</p>
<p class="code_title"><em>start.sh</em>: DigitalOcean start-up script.</p>

<pre class="prettyprint"><code><span class="pln">flask db upgrade
flask translate compile
gunicorn microblog</span><span class="pun">:</span><span class="pln">app</span></code></pre>
<p>Here I defined the command to start the web application as three commands in sequence. First I run a database migration upgrade, then I compile the language translations, and finally I start the server.</p>
<p>Because the first two sub-commands are based on the <code>flask</code> command, I need to add the <code>FLASK_APP</code> environment variable:</p>
<pre class="prettyprint"><code><span class="pln">$ doctl compute droplet update flask-microblog </span><span class="pun">--</span><span class="pln">env FLASK_APP</span><span class="pun">=</span><span class="pln">microblog</span><span class="pun">.</span><span class="pln">py</span></code></pre>
<p>The application also relies on other environment variables, such as those that configure the email server or the token for the live translations. Those need to be added with more <code>doctl compute droplet update</code> commands.</p>
<p>The <code>gunicorn</code> command is simpler than what I used for the Ubuntu deployment, because this server has a very good integration with the DigitalOcean environment. For example, the <code>$PORT</code> environment variable is honored by default, and instead of using the <code>-w</code> option to set the number of workers, DigitalOcean recommends adding a variable called <code>WEB_CONCURRENCY</code>, which <code>gunicorn</code> uses when <code>-w</code> is not provided, giving you the flexibility to control the number of workers without having to modify the start-up script.</p>
<h2>Deploying the Application</h2>
<p>All the preparatory steps are complete, so now it is time to run the deployment. To upload the application to DigitalOcean's servers for deployment, the <code>git push</code> command is used. This is similar to how you push changes in your local git repository to GitHub or other remote git server.</p>
<p>There are a couple of variations on how to do this, depending on how you created your git repository. If you are using my <code>v0.18</code> code, then you need to create a branch based on this tag, and push it as the remote <code>main</code> branch, as follows:</p>
<pre class="prettyprint"><code><span class="pln">$ git checkout </span><span class="pun">-</span><span class="pln">b deploy
$ git push digitalocean deploy</span><span class="pun">:</span><span class="pln">main</span></code></pre>
<p>If instead, you are working with your own repository, then your code is already in a <code>main</code> or <code>master</code> branch, so you first need to make sure that your changes are committed:</p>
<pre class="prettyprint"><code><span class="pln">$ git commit </span><span class="pun">-</span><span class="pln">a </span><span class="pun">-</span><span class="pln">m </span><span class="str">"digitalocean deployment changes"</span></code></pre>
<p>And then you can run the following to start the deployment:</p>
<pre class="prettyprint"><code><span class="pln">$ git push digitalocean main  </span><span class="com"># you may need to use "master" instead of "main"</span></code></pre>
<p>Regardless of how you push the branch, you should see the following output from DigitalOcean:</p>
<pre class="prettyprint"><code><span class="pln">$ git push digitalocean deploy</span><span class="pun">:</span><span class="pln">main
</span><span class="typ">Enumerating</span><span class="pln"> objects</span><span class="pun">:</span><span class="pln"> </span><span class="lit">264</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
</span><span class="typ">Counting</span><span class="pln"> objects</span><span class="pun">:</span><span class="pln"> </span><span class="lit">100</span><span class="pun">%</span><span class="pln"> </span><span class="pun">(</span><span class="lit">264</span><span class="pun">/</span><span class="lit">264</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
</span><span class="typ">Delta</span><span class="pln"> compression </span><span class="kwd">using</span><span class="pln"> up to </span><span class="lit">12</span><span class="pln"> threads
</span><span class="typ">Compressing</span><span class="pln"> objects</span><span class="pun">:</span><span class="pln"> </span><span class="lit">100</span><span class="pun">%</span><span class="pln"> </span><span class="pun">(</span><span class="lit">183</span><span class="pun">/</span><span class="lit">183</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
</span><span class="typ">Writing</span><span class="pln"> objects</span><span class="pun">:</span><span class="pln"> </span><span class="lit">100</span><span class="pun">%</span><span class="pln"> </span><span class="pun">(</span><span class="lit">264</span><span class="pun">/</span><span class="lit">264</span><span class="pun">),</span><span class="pln"> </span><span class="lit">59.44</span><span class="pln"> </span><span class="typ">KiB</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="lit">5.94</span><span class="pln"> </span><span class="typ">MiB</span><span class="pun">/</span><span class="pln">s</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
</span><span class="typ">Total</span><span class="pln"> </span><span class="lit">264</span><span class="pln"> </span><span class="pun">(</span><span class="pln">delta </span><span class="lit">132</span><span class="pun">),</span><span class="pln"> reused </span><span class="lit">143</span><span class="pln"> </span><span class="pun">(</span><span class="pln">delta </span><span class="lit">62</span><span class="pun">)</span><span class="pln">
remote</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Compressing</span><span class="pln"> source files</span><span class="pun">...</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
remote</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Building</span><span class="pln"> source</span><span class="pun">:</span><span class="pln">
remote</span><span class="pun">:</span><span class="pln">
remote</span><span class="pun">:</span><span class="pln"> </span><span class="pun">-----&gt;</span><span class="pln"> </span><span class="typ">Building</span><span class="pln"> on the </span><span class="typ">DigitalOcean</span><span class="pun">-</span><span class="lit">20</span><span class="pln"> stack
remote</span><span class="pun">:</span><span class="pln"> </span><span class="pun">-----&gt;</span><span class="pln"> </span><span class="typ">Determining</span><span class="pln"> which buildpack to </span><span class="kwd">use</span><span class="pln"> </span><span class="kwd">for</span><span class="pln"> </span><span class="kwd">this</span><span class="pln"> app
remote</span><span class="pun">:</span><span class="pln"> </span><span class="pun">-----&gt;</span><span class="pln"> </span><span class="typ">Python</span><span class="pln"> app detected
remote</span><span class="pun">:</span><span class="pln"> </span><span class="pun">-----&gt;</span><span class="pln"> </span><span class="typ">No</span><span class="pln"> </span><span class="typ">Python</span><span class="pln"> version was specified</span><span class="pun">.</span><span class="pln"> </span><span class="typ">Using</span><span class="pln"> the buildpack </span><span class="kwd">default</span><span class="pun">:</span><span class="pln"> python</span><span class="pun">-</span><span class="lit">3.9</span><span class="pun">.</span><span class="lit">6</span><span class="pln">
remote</span><span class="pun">:</span><span class="pln">        </span><span class="typ">To</span><span class="pln"> </span><span class="kwd">use</span><span class="pln"> a different version</span><span class="pun">,</span><span class="pln"> see</span><span class="pun">:</span><span class="pln"> https</span><span class="pun">:</span><span class="com">//devcenter.digitalocean.com/articles/...</span><span class="pln">
remote</span><span class="pun">:</span><span class="pln"> </span><span class="pun">-----&gt;</span><span class="pln"> </span><span class="typ">Installing</span><span class="pln"> python</span><span class="pun">-</span><span class="lit">3.9</span><span class="pun">.</span><span class="lit">6</span><span class="pln">
remote</span><span class="pun">:</span><span class="pln"> </span><span class="pun">-----&gt;</span><span class="pln"> </span><span class="typ">Installing</span><span class="pln"> pip </span><span class="lit">20.2</span><span class="pun">.</span><span class="lit">4</span><span class="pun">,</span><span class="pln"> setuptools </span><span class="lit">47.1</span><span class="pun">.</span><span class="lit">1</span><span class="pln"> </span><span class="kwd">and</span><span class="pln"> wheel </span><span class="lit">0.36</span><span class="pun">.</span><span class="lit">2</span><span class="pln">
remote</span><span class="pun">:</span><span class="pln"> </span><span class="pun">-----&gt;</span><span class="pln"> </span><span class="typ">Installing</span><span class="pln"> </span><span class="typ">SQLite3</span><span class="pln">
remote</span><span class="pun">:</span><span class="pln"> </span><span class="pun">-----&gt;</span><span class="pln"> </span><span class="typ">Installing</span><span class="pln"> requirements </span><span class="kwd">with</span><span class="pln"> pip
</span><span class="pun">...</span><span class="pln">
remote</span><span class="pun">:</span><span class="pln">
remote</span><span class="pun">:</span><span class="pln"> </span><span class="pun">-----&gt;</span><span class="pln"> </span><span class="typ">Discovering</span><span class="pln"> process types
remote</span><span class="pun">:</span><span class="pln">        </span><span class="typ">Procfile</span><span class="pln"> declares types </span><span class="pun">-&gt;</span><span class="pln"> web
remote</span><span class="pun">:</span><span class="pln">
remote</span><span class="pun">:</span><span class="pln"> </span><span class="pun">-----&gt;</span><span class="pln"> </span><span class="typ">Compressing</span><span class="pun">...</span><span class="pln">
remote</span><span class="pun">:</span><span class="pln">        </span><span class="typ">Done</span><span class="pun">:</span><span class="pln"> </span><span class="lit">69.2M
remote</span><span class="pun">:</span><span class="pln"> </span><span class="pun">-----&gt;</span><span class="pln"> </span><span class="typ">Launching</span><span class="pun">...</span><span class="pln">
remote</span><span class="pun">:</span><span class="pln">        </span><span class="typ">Released</span><span class="pln"> v7
remote</span><span class="pun">:</span><span class="pln">        https</span><span class="pun">:</span><span class="com">//your-droplet-ip/ deployed to DigitalOcean
remote</span><span class="pun">:</span><span class="pln">
remote</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Verifying</span><span class="pln"> deploy</span><span class="pun">...</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">.</span><span class="pln">
</span><span class="typ">To</span><span class="pln"> https</span><span class="pun">:</span><span class="com">//git.digitalocean.com/flask-microblog.git
 </span><span class="pun">*</span><span class="pln"> </span><span class="pun">[</span><span class="kwd">new</span><span class="pln"> branch</span><span class="pun">]</span><span class="pln">      deploy </span><span class="pun">-&gt;</span><span class="pln"> main</span></code></pre>
<p>The label <code>digitalocean</code> that we used in the <code>git push</code> command is the remote that was automatically added by the DigitalOcean CLI when the droplet was created. The <code>deploy:main</code> argument means that I'm pushing the code from the local repository referenced by the <code>deploy</code> branch to the <code>main</code> branch on the DigitalOcean repository. When you work with your own projects, you will likely be pushing with the command <code>git push digitalocean main</code>, which pushes your local <code>main</code> branch. Because of the way this project is structured, I'm pushing a branch that is not <code>main</code>, but the destination branch on the DigitalOcean side always needs to be <code>main</code> or <code>master</code> as those are the only branch names that DigitalOcean accepts for deployment.</p>
<p>And that is it, the application should now be deployed at the IP address that you were given in the output of the command that created the droplet. In my case, the IP address was <em>your-droplet-ip</em>, so that is what I need to type to access the application.</p>
<p>If you want to see the log entries for the running application, use the <code>doctl logs</code> command. This can be useful if for any reason the application fails to start. If there were any errors, those will be in the logs.</p>
<h2>Deploying Application Updates</h2>
<p>To deploy a new version of the application, you just need to run a new <code>git push</code> command with the new code. This will repeat the deployment process, take the old deployment offline, and then replace it with the new code. The commands in the start-up script will run again as part of the new deployment, so any new database migrations or translations will be updated during the process.</p>
<p>Continue on to the <a href="/post/the-flask-mega-tutorial-part-xix-deployment-on-docker-containers">next chapter</a>.</p></div>
